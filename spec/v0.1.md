# UPLim v0.1 Language Specification

This document defines the frozen v0.1 specification for UPLim. It serves as the authoritative guide for implementation.

## 1. Formal EBNF Grammar

Notes:

- Whitespace and comments are ignored between tokens.
- Newlines are not significant.
- Blocks use `{ ... }`.
- Semicolons are optional; statements are delimited by `}` or by lookahead.

### 1.1 Lexical

```ebnf
letter      = "A"…"Z" | "a"…"z" | "_" ;
digit       = "0"…"9" ;
hexdigit    = digit | "A"…"F" | "a"…"f" ;

ident       = letter , { letter | digit } ;
int_lit     = digit , { digit } ;
float_lit   = digit , { digit } , "." , digit , { digit } ;
bool_lit    = "true" | "false" ;

string_lit  = '"' , { str_char } , '"' ;
str_char    = ? any char except " and \ ? | escape ;
escape      = "\" , ( "\" | '"' | "n" | "r" | "t" ) ;

comment     = "//" , { ? not newline ? }
            | "/*" , { ? anything ? } , "*/" ;

kw          = "let" | "var" | "fn" | "pub" | "struct" | "enum"
            | "import" | "extern" | "return"
            | "if" | "else" | "while" | "for" | "in"
            | "match" | "async" | "await" ;

op          = "+" | "-" | "*" | "/" | "%"
            | "==" | "!=" | "<" | "<=" | ">" | ">="
            | "&&" | "||" | "!"
            | "="
            | ".."
            | "." | ":" | "," | "->" | "=>" ;
```

### 1.2 Program structure

```ebnf
program      = { item } ;

item         = import_decl
             | struct_decl
             | enum_decl
             | func_decl
             | extern_decl ;

import_decl  = "import" , module_path , ";"? ;
module_path  = ident , { "." , ident } ;

extern_decl  = "extern" , "fn" , ident , "(" , param_list? , ")" , "->" , type , ";"? ;
```

### 1.3 Declarations

```ebnf
struct_decl  = "struct" , ident , "{" , { field_decl } , "}" ;
field_decl   = ident , ":" , type , ";"? ;

enum_decl    = "enum" , ident , "{" , enum_variant , { "," , enum_variant } , ","? , "}" ;
enum_variant = ident ;  (* v0.1: no payload; payloads can be v0.2 *)

func_decl    = visibility? , async_kw? , "fn" , ident ,
               "(" , param_list? , ")" , "->" , type , block ;

visibility   = "pub" ;
async_kw     = "async" ;

param_list   = param , { "," , param } , ","? ;
param        = ident , ":" , type ;
```

### 1.4 Types

```ebnf
type         = core_type
             | array_type
             | map_type
             | result_type
             | named_type ;

core_type    = "Int" | "Float" | "Bool" | "String" | "Void" | "Any" ;

array_type   = "[" , type , "]" ;
map_type     = "Map" , "[" , type , "," , type , "]" ;
result_type  = "Result" , "[" , type , "," , type , "]" ;

named_type   = ident ;  (* structs, enums, user types *)
```

### 1.5 Statements and blocks

```ebnf
block        = "{" , { statement } , "}" ;

statement    = let_stmt
             | var_stmt
             | assign_stmt
             | return_stmt
             | while_stmt
             | for_stmt
             | expr_stmt ;

let_stmt     = "let" , ident , ( ":" , type )? , "=" , expr , ";"? ;
var_stmt     = "var" , ident , ( ":" , type )? , "=" , expr , ";"? ;

assign_stmt  = lvalue , "=" , expr , ";"? ;
lvalue       = ident
             | expr , "." , ident
             | expr , "[" , expr , "]" ;

return_stmt  = "return" , expr? , ";"? ;

while_stmt   = "while" , expr , block ;
for_stmt     = "for" , ident , "in" , range_expr , block ;
range_expr   = expr , ".." , expr ;

expr_stmt    = expr , ";"? ;
```

### 1.6 Expressions (precedence climbing)

```ebnf
expr         = if_expr
             | match_expr
             | logic_or ;

if_expr      = "if" , expr , block , "else" , ( block | if_expr ) ;

match_expr   = "match" , expr , "{" , { match_arm } , "}" ;
match_arm    = pattern , "=>" , expr , ";"? ;
pattern      = "_" | ident | qualified_ident ;
qualified_ident = ident , "." , ident ; (* enum variant reference *)

logic_or     = logic_and , { "||" , logic_and } ;
logic_and    = equality  , { "&&" , equality } ;
equality     = compare   , { ( "==" | "!=" ) , compare } ;
compare      = term      , { ( "<" | "<=" | ">" | ">=" ) , term } ;
term         = factor    , { ( "+" | "-" ) , factor } ;
factor       = unary     , { ( "*" | "/" | "%" ) , unary } ;

unary        = ( "!" | "-" ) , unary
             | call ;

call         = primary , { call_suffix } ;
call_suffix  = "(" , arg_list? , ")"
             | "." , ident
             | "[" , expr , "]" ;

arg_list     = expr , { "," , expr } , ","? ;

primary      = int_lit | float_lit | bool_lit | string_lit
             | ident
             | "(" , expr , ")"
             | struct_init
             | map_lit
             | array_lit
             | ok_expr
             | err_expr
             | await_expr ;

await_expr   = "await" , expr ;

array_lit    = "[" , ( expr , { "," , expr } , ","? )? , "]" ;

map_lit      = "{" , ( map_entry , { "," , map_entry } , ","? )? , "}" ;
map_entry    = string_lit , ":" , expr ;

struct_init  = ident , "{" , ( init_field , { "," , init_field } , ","? )? , "}" ;
init_field   = ident , ":" , expr ;

ok_expr      = "Ok" , "(" , expr , ")" ;
err_expr     = "Err" , "(" , expr , ")" ;
```

## 2. AST Specification

### 2.1 Top-level

- `Program { items: Item[] }`
- `Item` =
  - `ImportDecl { path: string[] }`
  - `StructDecl { name: Ident, fields: FieldDecl[], pub: bool }`
  - `EnumDecl { name: Ident, variants: Ident[], pub: bool }`
  - `FuncDecl { name: Ident, params: Param[], ret: TypeRef, body: Block, pub: bool, async: bool }`
  - `ExternDecl { name: Ident, params: Param[], ret: TypeRef }`

### 2.2 Types

- `TypeRef` =
  - `CoreType("Int"|"Float"|"Bool"|"String"|"Void"|"Any")`
  - `ArrayType { elem: TypeRef }`
  - `MapType { key: TypeRef, val: TypeRef }`
  - `ResultType{ ok: TypeRef, err: TypeRef }`
  - `NamedType { name: Ident }`

### 2.3 Statements

- `Block { stmts: Stmt[] }`
- `Stmt` =
  - `LetStmt { name: Ident, annType?: TypeRef, init: Expr }`
  - `VarStmt { name: Ident, annType?: TypeRef, init: Expr }`
  - `AssignStmt { target: LValue, value: Expr }`
  - `ReturnStmt { value?: Expr }`
  - `WhileStmt { cond: Expr, body: Block }`
  - `ForStmt { name: Ident, start: Expr, end: Expr, body: Block }`
  - `ExprStmt { expr: Expr }`

### 2.4 Expressions

- `Expr` =
  - `LitInt`, `LitFloat`, `LitBool`, `LitString`
  - `Var`, `Unary`, `Binary`
  - `IfExpr`, `MatchExpr`
  - `Call`, `Member`, `Index`
  - `ArrayLit`, `MapLit`, `StructInit`
  - `Ok`, `Err`, `Await`

## 3. Type Checker Rules (v0.1)

(See specific rules in task description)

## 4. Standard Library (v0.1)

- `std.core`: `print`, `panic`, `assert`
- `std.math`: `abs`, `min`, `max`
- `std.string`: `concat`, `eq`, `len`
- `std.array`: `newInt`, `pushInt`, `getInt`, `setInt`, `lenInt`
