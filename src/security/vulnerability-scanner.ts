// Engine Module: Security Analysis
// Scans for memory safety, threading risks, and dangerous constructs

export type SecurityThreat = {
  id: string;
  category: 'memory' | 'concurrency' | 'injection' | 'overflow' | 'unsafe_api';
  severity: 'low' | 'medium' | 'high' | 'critical';
  description: string;
  location: { line: number; column: number };
  cwe?: string; // Common Weakness Enumeration ID
  fix: string;
};

export type SecurityReport = {
  code: string;
  timestamp: Date;
  threats: SecurityThreat[];
  riskScore: number; // 0-100
  safe: boolean;
};

export class VulnerabilityScanner {
  private threatPatterns: Map<string, RegExp> = new Map();

  constructor() {
    this.initializeThreatPatterns();
  }

  private initializeThreatPatterns() {
    this.threatPatterns.set('null-deref', /\bnull\b|\bundefined\b/);
    this.threatPatterns.set('buffer-overflow', /\b(strcpy|strcat|gets|sprintf)\b/);
    this.threatPatterns.set('sql-injection', /SELECT.*\+.*|INSERT.*\+.*/i);
    this.threatPatterns.set('eval-usage', /\beval\(/);
    this.threatPatterns.set('unsafe-pointer', /\b(malloc|free|delete|new)\b/);
  }

  scan(code: string): SecurityReport {
    const threats: SecurityThreat[] = [];

    // Check for null/undefined
    if (this.threatPatterns.get('null-deref')!.test(code)) {
      threats.push({
        id: `threat-null-${Date.now()}`,
        category: 'memory',
        severity: 'high',
        description: 'Potential null pointer dereference',
        location: { line: 0, column: 0 },
        cwe: 'CWE-476',
        fix: 'Use Option<T> type for nullable values',
      });
    }

    // Check for eval
    if (this.threatPatterns.get('eval-usage')!.test(code)) {
      threats.push({
        id: `threat-eval-${Date.now()}`,
        category: 'injection',
        severity: 'critical',
        description: 'Use of eval() function detected',
        location: { line: 0, column: 0 },
        cwe: 'CWE-95',
        fix: 'Remove eval() and use safe alternatives',
      });
    }

    // Check for SQL injection patterns
    if (this.threatPatterns.get('sql-injection')!.test(code)) {
      threats.push({
        id: `threat-sql-${Date.now()}`,
        category: 'injection',
        severity: 'critical',
        description: 'Potential SQL injection vulnerability',
        location: { line: 0, column: 0 },
        cwe: 'CWE-89',
        fix: 'Use parameterized queries or ORM',
      });
    }

    // Check for unsafe memory operations
    if (this.threatPatterns.get('unsafe-pointer')!.test(code)) {
      threats.push({
        id: `threat-memory-${Date.now()}`,
        category: 'memory',
        severity: 'high',
        description: 'Unsafe memory operation detected',
        location: { line: 0, column: 0 },
        cwe: 'CWE-404',
        fix: 'Use automatic memory management',
      });
    }

    const riskScore = this.calculateRiskScore(threats);

    return {
      code,
      timestamp: new Date(),
      threats,
      riskScore,
      safe: threats.length === 0,
    };
  }

  private calculateRiskScore(threats: SecurityThreat[]): number {
    const severityScores = {
      low: 10,
      medium: 30,
      high: 60,
      critical: 100,
    };

    if (threats.length === 0) return 0;

    const totalScore = threats.reduce((sum, threat) => {
      return sum + severityScores[threat.severity];
    }, 0);

    return Math.min(100, totalScore / threats.length);
  }

  scanConcurrency(code: string): SecurityThreat[] {
    const threats: SecurityThreat[] = [];

    // Check for potential race conditions
    if (code.includes('async') && code.includes('let')) {
      // Simplified check for shared mutable state in async context
      threats.push({
        id: `race-${Date.now()}`,
        category: 'concurrency',
        severity: 'medium',
        description: 'Potential race condition with shared state',
        location: { line: 0, column: 0 },
        cwe: 'CWE-362',
        fix: 'Use immutable data structures or proper synchronization',
      });
    }

    return threats;
  }
}

export const vulnerabilityScanner = new VulnerabilityScanner();
