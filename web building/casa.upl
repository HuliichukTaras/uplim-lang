# ==========================================
# UPLim Smart Home System (Casa OS) v2.0
# ==========================================
# This program simulates a complete smart home environment
# demonstrating UPLim's capabilities in handling complex Logic.

say "Booting Casa OS..."

# ------------------------------------------
# 1. Configuration & Constants
# ------------------------------------------
let system_name = "Casa de Tara"
let version = "2.0.1-beta"
let debug_mode = true
let max_retry_attempts = 3
let comfort_temp_min = 20
let comfort_temp_max = 24

# ------------------------------------------
# 2. System Helpers
# ------------------------------------------

fn log(level, message) {
    if debug_mode {
        say "[" + level + "] " + message
    }
}

fn format_status(device, state) {
    return device + " is currently " + state
}

fn calculate_power_usage(on_time, wattage) {
    # Simple power calculation
    return on_time * wattage / 1000
}

# ------------------------------------------
# 3. Data Structures (Simulated Classes)
# ------------------------------------------

# Constructor for a Room
fn create_room(name, floor) {
    return {
        "name": name,
        "floor": floor,
        "lights_on": false,
        "temperature": 21,
        "secure": true
    }
}

# Constructor for a Device
fn create_device(id, type, room_name) {
    return {
        "id": id,
        "type": type,
        "room": room_name,
        "active": false,
        "usage_hours": 0
    }
}

# ------------------------------------------
# 4. System Initialization
# ------------------------------------------

log("INFO", "Initializing zones...")

let rooms = [
    create_room("Living Room", 1),
    create_room("Kitchen", 1),
    create_room("Master Bed", 2),
    create_room("Guest Bed", 2),
    create_room("Garage", 1)
]

log("INFO", "Scanning for devices...")

let devices = [
    create_device("light_lr_1", "Light", "Living Room"),
    create_device("light_lr_2", "Light", "Living Room"),
    create_device("thermostat_1", "Thermostat", "Living Room"),
    create_device("fridge_1", "Appliance", "Kitchen"),
    create_device("light_ki_1", "Light", "Kitchen"),
    create_device("lock_front", "Security", "Living Room"),
    create_device("lock_garage", "Security", "Garage"),
    create_device("opener_garage", "Motor", "Garage")
]

# ------------------------------------------
# 5. Core Logic & Control
# ------------------------------------------

fn get_devices_in_room(target_room) {
    # Filter devices by room name
    return [ d | d in devices if d["room"] == target_room ]
}

fn toggle_room_lights(room_obj, state) {
    # Note: Objects are effectively maps in this sim
    # We simulate updating the state
    let action = "OFF"
    if state { action = "ON" }
    
    log("ACTION", "Turning lights " + action + " in " + room_obj["name"])
    
    # Update linked devices
    let room_devs = get_devices_in_room(room_obj["name"])
    
    # Simulate device state update
    # In a real app we'd map over them and update 'active' property
    return state
}

fn check_security() {
    log("SEC", "Running perimeter scan...")
    
    let security_devices = [ d | d in devices if d["type"] == "Security" ]
    let breached = false
    
    # Check each security device
    # (Simulating a loop since direct iteration might be verbose)
    
    if breached {
        log("ALARM", "INTEGRITY BREACH DETECTED")
        return false
    } else {
        log("SEC", "Perimeter secure.")
        return true
    }
}

fn optimize_energy() {
    log("ENERGY", "Optimizing power consumption...")
    let total_load = 0
    
    # Calculate synthetic load
    let active_count = 5 # Simulated active devices
    total_load = calculate_power_usage(active_count, 60)
    
    say "Current estimated load: " + total_load + " kWh"
    
    if total_load > 10 {
        log("WARN", "High energy usage detected. Activating Eco Mode.")
        return false
    }
    return true
}

# ------------------------------------------
# 6. Scenario Simulation
# ------------------------------------------

fn run_morning_routine() {
    say "--- Executing Morning Routine ---"
    
    log("ROUTINE", "Waking up house...")
    
    # Adjust temperature
    log("HVAC", "Targeting 22C degrees")
    
    # Open blinds (simulated)
    log("BLINDS", "Opening all blinds")
    
    # Turn on kitchen coffee maker
    log("KITCHEN", "Brewing coffee...")
}

fn run_night_routine() {
    say "--- Executing Night Routine ---"
    
    # Check locks
    let secure = check_security()
    
    if secure {
        log("SYSTEM", "House is locked down.")
    } else {
        log("ALERT", "Check doors!")
    }
    
    # Turn off all lights
    log("LIGHTS", "Fading out all zones...")
}

# ------------------------------------------
# 7. Main Event Loop Simulation
# ------------------------------------------

log("SYSTEM", "System ready. Listening for events.")
say ""

# Simulation of time passing
let hours = [6, 7, 8, 9, 12, 17, 18, 19, 20, 22, 23]

# Loop through "hours" of the day
# Note: Using recursion or map for iteration if 'foreach' isn't standard yet
# But array comprehension is good for this simulation.

fn tick(h) {
    say "TIME: " + h + ":00"
    
    if h == 6 {
        run_morning_routine()
    }
    
    if h == 8 {
        log("SYSTEM", "User left home. Arming security.")
        check_security()
        toggle_room_lights(rooms[0], false)
    }
    
    if h == 17 {
        log("SYSTEM", "User returning.")
        optimize_energy()
    }
    
    if h == 20 {
        log("ENTERTAINMENT", "Cinema mode activated in Living Room")
    }
    
    if h == 22 {
        run_night_routine()
    }
    
    say "..."
    return h
}

# Execute the day
let timeline = [ tick(h) | h in hours ]

# ------------------------------------------
# 8. Diagnostics Report
# ------------------------------------------

say ""
say "=========================================="
say "DAILY REPORT"
say "=========================================="
say "System: " + system_name
say "Version: " + version
say "Security Incidents: 0"
say "Energy Efficiency: 94%"

# Check hardware status
fn ping_device(d) {
    # Simulate network latency
    # In real UPLim we might define complex matchers
    if d["type"] == "Security" {
        return d["id"] + ": OK (Encrypted)"
    }
    return d["id"] + ": OK"
}

let report = [ ping_device(d) | d in devices ]

# Print first 5 devices
say "Hardware Status:"
say report

say "=========================================="
say "End of Line."
