# ==========================================
# UPLim Smart Home System (Casa OS) v3.0
# Demonstrating UPLim v0.3 Features
# ==========================================

say "Booting Casa OS v3.0 (UPLim v0.3)..."

# ------------------------------------------
# 1. Type Definitions (Structs & Enums)
# ------------------------------------------

enum DeviceType {
    Light,
    Thermostat,
    Appliance,
    Security,
    Motor
}

enum Status {
    Off,
    On,
    Active,
    Standby,
    Locked,
    Unlocked,
    Breached
}

struct Room {
    name: string,
    floor: int,
    temperature: int
}

struct Device {
    id: string,
    type: DeviceType,
    room: string,
    status: Status,
    usage: int
}

# ------------------------------------------
# 2. Policy Definitions
# ------------------------------------------

policy SecurityRules {
    description: "Ensure house is safe"
    enforce: strict
}

# ------------------------------------------
# 3. Data Initialization
# ------------------------------------------

let living_room = Room { 
    name: "Living Room", 
    floor: 1, 
    temperature: 21 
}

let kitchen = Room { 
    name: "Kitchen", 
    floor: 1, 
    temperature: 22 
}

let light1 = Device { 
    id: "light_lr_1", 
    type: DeviceType.Light, 
    room: "Living Room", 
    status: Status.Off,
    usage: 0 
}

let front_lock = Device {
    id: "lock_front",
    type: DeviceType.Security,
    room: "Living Room",
    status: Status.Locked,
    usage: 5
}

let devices = [light1, front_lock]

# ------------------------------------------
# 4. Functions & Logic
# ------------------------------------------

fn get_device_info(d) {
    # Using Pattern Matching on Enum
    let status_msg = match d.status {
        Status.On => "is ON and consuming power",
        Status.Off => "is OFF",
        Status.Locked => "is SECURE",
        Status.Breached => "TRIGGERED SECURITY ALERT!",
        _ => "is in standby"
    }
    
    return d.id + " (" + d.room + ") " + status_msg
}

fn toggle_power(d) {
    # Immutable update using .with()
    
    let next_status = match d.status {
        Status.Off => Status.On,
        Status.On => Status.Off,
        _ => d.status
    }
    
    # Return new device instance with updated status
    return d.with(status = next_status)
}

# ------------------------------------------
# 5. Execution Flow
# ------------------------------------------

say "--- System Status ---"
say get_device_info(light1)
say get_device_info(front_lock)

say "--- User Action: Turn On Light ---"
# Using .with to update state
let light1_active = toggle_power(light1)

say "Original Light State: " + get_device_info(light1)
say "New Light State:      " + get_device_info(light1_active)

say "--- Security Scan ---"
# Struct property access
say "Checking " + front_lock.room + " security..."

fn scan_security(dev) {
    let safe = match dev.status {
        Status.Locked => true,
        Status.Active => true,
        _ => false
    }
    
    if safe {
        say "Device " + dev.id + ": OK"
    } else {
        say "Device " + dev.id + ": WARNING"
    }
}

scan_security(front_lock)

say "System Init Complete."
